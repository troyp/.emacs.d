(defun lines (&rest ss)
  (mapconcat 'identity ss "\n"))


;; ******************************
;; *                            *
;; * HEADING PRINTING FUNCTIONS *
;; *                            *
;; ******************************

(setq *box-heading-symbol* ?*)
(setq *box-heading-margin* 1)
(setq *banner-heading-symbol* ?=)
(setq *heading-symbol* ?-)

(defun box-heading (s)
  (interactive)
  (unless (boundp '*box-heading-symbol*) (setq *box-heading-symbol* ?*))
  (unless (boundp '*box-heading-margin*) (setq *box-heading-margin* 1))
  (let* ((n   (length s))
	 (d   (or *box-heading-margin* 1))
	 (sym (string (or *box-heading-symbol* ?*)))
	 (spc 32)    ; space
	 (N   (+ n 2 (* 2 d)))
	 (v-margin (make-string d spc))
	 (h-border (make-string N *box-heading-symbol*))
	 (h-margin (concat sym (make-string (- N 2) spc) sym))
	 (textline (concat sym v-margin s v-margin sym)))
    (insert
     (lines h-border
	    h-margin
	    textline
	    h-margin
	    h-border)
     "\n")))

(defun box-heading-comment (s)
  (interactive "s" "heading: ")
  (let ((start (point)))
    (box-heading s)
    (comment-region start (point))))


;; *******************************
;; *                             *
;; * LINE-BASED EDITING COMMANDS *
;; *                             *
;; *******************************

(defun remove-current-line ()
  (interactive)
  (let ((orig-col (current-column)))
    (move-beginning-of-line nil)
    (kill-whole-line)
    (move-to-column orig-col)))
(defun cut-current-line ()
  (interactive)
  (let ((orig-col (current-column)))
    (move-beginning-of-line nil)
    (append-next-kill)
    (kill-whole-line)
    (move-to-column orig-col)))
(defun copy-current-line ()
  (interactive)
  (let ((orig-col (current-column)))
    (move-beginning-of-line nil)
    (push-mark (point))
    (move-end-of-line nil)
    (kill-ring-save (mark) (point))
    (newline)
    (yank)
    (move-to-column orig-col)))


;; ***********************************
;; *                                 *
;; * ECLIPSE-STYLE BEGINNING-OF-LINE *
;; *                                 *
;; ***********************************

;; adapted from move-beginning-of-line from simple.el (emacs source)
;; modified by Troy Pracy
;; license: emacs license (GPL3 or later)
(defun move-beginning-of-line-or-text (arg)
  "Move point to beginning of current line as displayed.
\(If there's an image in the line, this disregards newlines
which are part of the text that the image rests on.)

With argument ARG not nil or 1, move forward ARG - 1 lines first.
If point reaches the beginning or end of buffer, it stops there.
To ignore intangibility, bind `inhibit-point-motion-hooks' to t."
  (interactive "^p")
  (or arg (setq arg 1))

  (let ((orig (point))
	first-vis first-vis-field-value)

    ;; Move by lines, if ARG is not 1 (the default).
    (if (/= arg 1)
	(let ((line-move-visual nil))
	  (line-move (1- arg) t)))

    ;; Move back to indentation
    (back-to-indentation)
    (when (= (point) orig)
      ;; Move to beginning-of-line, ignoring fields and invisible text.
      (skip-chars-backward "^\n")
      (while (and (not (bobp)) (invisible-p (1- (point))))
	(goto-char (previous-char-property-change (point)))
	(skip-chars-backward "^\n"))

      ;; Now find first visible char in the line
      (while (and (not (eobp)) (invisible-p (point)))
	(goto-char (next-char-property-change (point))))
      (setq first-vis (point))

      ;; See if fields would stop us from reaching FIRST-VIS.
      (setq first-vis-field-value
	    (constrain-to-field first-vis orig (/= arg 1) t nil))

      (goto-char (if (/= first-vis-field-value first-vis)
		     ;; If yes, obey them.
		     first-vis-field-value
		   ;; Otherwise, move to START with attention to fields.
		   ;; (It is possible that fields never matter in this case.)
		   (constrain-to-field (point) orig
				       (/= arg 1) t nil))))))


;; *******************************
;; *                             *
;; * FILE MANIPULATION FUNCTIONS *
;; *                             *
;; *******************************
(defun rename-file-and-buffer (name)
  (interactive "snew name: ")
  (let ((orig-name (buffer-name)))
    (if orig-name
  	(progn
  	  (set-visited-file-name name t)
  	  (save-buffer)
  	  (delete-file orig-name))
      (if (y-or-n-p "No file associated with buffer. Create new file? ")
  	  (write-file name)
  	(error "aborted")))
    (message name orig-name)))

(defun sudo-open-file (filename &optional wildcards)
  (interactive
   (find-file-read-args "Find file: "
                        (confirm-nonexistent-file-or-buffer)))
  (require 'tramp)
  (let ((f (concat "/sudo::" (expand-file-name filename))))
    (find-file f wildcards)))


;; ************
;; *          *
;; * COMMENTS *
;; *          *
;; ************

(defun comment-line (arg)
  "Comment out or uncomment a single line, n lines below the current line."
  (interactive "*P")
  (save-excursion
    (let ((n (cond
	      ((not arg) 0)
	      ((stringp arg) (string-to-number arg))
	      (t arg))))
      (next-line n)
      (move-beginning-of-line 1)
      (push-mark (point))
      (move-end-of-line 1)
      (comment-or-uncomment-region (mark) (point)))))
  
(defun comment-line-or-region (arg)
  "If the region is active and `transient-mark-mode' is on, call
`comment-region' (unless it only consists of comments, in which
case it calls `uncomment-region').
Else, call `comment-line'."
  (interactive "*P")
  (comment-normalize-vars)
  (if (and mark-active transient-mark-mode)
      (comment-or-uncomment-region (region-beginning) (region-end) arg)
    (comment-line 0)))
